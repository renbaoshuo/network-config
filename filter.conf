function net_len_too_long() {
    case net.type {
        NET_IP4: return net.len > 24; # IPv4 CIDR 大于 /24 为太长
        NET_IP6: return net.len > 48; # IPv6 CIDR 大于 /48 为太长
        else: print "net_len_too_long: unexpected net.type ", net.type, " ", net; return false;
    }
}

filter import_from_transit {
    bgp_large_community.add((OWNAS, 1, bgp_path.first));
    if net ~ OWNNETSETv6 then reject;  # 不收别人发来的自己网络的前缀
    if bgp_path ~ 141776 then reject;  # 不收经过自己网络的前缀
    if net_len_too_long() then reject; # 前缀太长不收
    if (roa_check(public_roa_v6, net, bgp_path.last) = ROA_INVALID) then {
        # print "ROA check failed for ", net, " ASN ", bgp_path.last;
        reject; # 拒绝接收 ROA 错误的路由
    }
    accept;
}

filter export_to_transit {
    if source ~ [RTS_STATIC, RTS_BGP] && net ~ OWNNETSETv6 then accept;
    reject;
}

filter import_from_peer {
    bgp_large_community.add((OWNAS, 2, bgp_path.first));
    if net ~ OWNNETSETv6 then reject;  # 不收别人发来的自己网络的前缀
    if bgp_path ~ 141776 then reject;  # 不收经过自己网络的前缀
    if net_len_too_long() then reject; # 前缀太长不收
    if (roa_check(public_roa_v6, net, bgp_path.last) = ROA_INVALID) then {
        # print "ROA check failed for ", net, " ASN ", bgp_path.last;
        reject; # 拒绝接收 ROA 错误的路由
    }
    accept;
}

filter export_to_peer {
    if source ~ [RTS_STATIC, RTS_BGP] && net ~ OWNNETSETv6 then accept;
    reject;
}

filter import_from_internal {
    bgp_large_community.add((OWNAS, 3, bgp_path.first));
    bgp_large_community.add((CONFEDERATIONAS, 3, bgp_path.first));
    if (CONFEDERATIONAS, 3, bgp_path.first) ~ bgp_large_community then reject; # 不收本机发到内网的路由
    accept;
}

filter export_to_internal {
    if source ~ [RTS_STATIC, RTS_BGP] then accept;
    reject;
}
